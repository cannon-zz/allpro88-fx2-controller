mistakes:

U2, the 3-pin regulator, should have been a TO-252-3 footprint.  that's the size of the part that was on the devel board I've salvaged all the components from.  I'm going to have to special-order a regulator to fit a SOT-89-3 footprint.  argh.  with shipping it's going to be an expensive mistake.  UPDATE:  found an online supplier in Tokyo I didn't know about before, and it was only 600 yen to fix the mistake and less than 24 hours (100 yen for a pack of 6 regulators in SOT-89-3 packges, and 500 yen to have it delivered the next day), yay.

the footprints for C7 and C5 are little too small, but they worked OK.  I have not changed them in the pcb layout.

the EEPROM ENABLE jumper is actually an EEPROM DISABLE jumper.  removing the jumper enables the eeprom, installing the jumper disables it.  the circuit works, everything is OK, it's just backwards from the message that got printed on the board.  argh.  this has been fixed in the design files.

there are nowhere near enough decoupling capacitors on U1:  there should be one on every +ve supply pin.  the application circuit I was referring to made it appear as though only a single one was required, but it was actually implying that one should be put on every VCC pin.  oops.  the board seems to work fine, I've used it quite a bit without any evidence of instability.  nevertheless, I have modified the PCB layout to replace the individual VCC traces with a filled zone on the top side of the board.  this should make the impedance between each pin and the one, single, decoupling capacitor I included nearly 0.  I have not tried to bodge in decoupling capacitors on every pin.  there is no room, they would have to be installed on the underside of the board, but I think that's the normal way this would be layed out.

following the recommendations of the Guide to a Successful EZ-USB FX2LP Hardware Design, I have added a capacitor and drain resistor to the circuitry on the wakeup line, and increased the vbus-->wakeup pull-up resistor from 10 kOhm to 30 kOhm.  these changes have been made in the schematic and pcb layout.  I'll have to bodge these changes into the board with through-hole components using the pads that were put in for bodges like this.

	currently installed:  R4 = 10 kOhm

	modifying the other components accordingly:
	R4 = 10 kOhm		should be 30 kOhm
	R13 = 20 kOhm		should be 60 kOhm
	(red black orange)	(blue black orange)
	C10 = 0.33 uF		should be 0.1 uF
	(334)			(104)

	from parts bin:
	R13 = 22 kOhm
	C10 = 0.47 uF (polarized tantalum)

the polarized tantalum has 6 Ohm ESR.  it's a crappy capacitor.  good to find a use for it where its specs don't matter.

after installing these I confirmed the WAKEUP pin is pulled to 3.34 V when the USB cable is connected to the host, and 0 V when disconnected.  UPDATE:  I have also now gotten the firmware to monitor the USB VBUS level via the WAKEUP pin and turn the USB pull-up resistor on and off as needed when a cable disconnect is noticed.

the hole used to pass a zip tie through for strain relief on the soldered-in USB cable worked out perfectly.  I wish there was one on the other side to provide strain relief for the power cable.

the board is quite small and light and I'm confident the friction in the 36 pin header connector is enough to keep it installed properly, but it would provide extra assurace to add an extension to the top of the board to press against the inside of the metal cage used to secure the PCBs to the motherboard.  what I'm worried about is thermal cycling:  because of the way it's installed gravity is pulling the board off the connector, not pushing it down onto it, so turning the system on and off and on and off, warming and cooling and warming and cooling, might work the board loose over time.

I have cleaned up some other traces here and there to make the layout look nicer and improve copper fill coverage in areas.

what is actually installed in my programmer is the original board with the bodged-in capacitor and resistor as described above.  it works fine.  I have not bothered ordering a set of the new design and transfering the components.

I have decided that the "PSEN" line should not be connected:  it's not connected to anything now and the programmer seems to work fine, and a schematic for the ISA interface board shows it being not connected to anything there.  therefore I have updated both the schematic and the PCB layout to remove all of the optional resistors and jumpers associated with that connection.  I have left a single through-hole pad routed to it in case I do decide I want to jumper something to it.  the "activity" LED is wired directly to the extra GPIO.


GPIF:

when I was planning the design, I had no previous experience with the FX2 chip, the 400 page TRM was overwhelming, but from what I could understand with my limited understanding of the chip the GPIF was not going to help.  it looked to me like it was intended to be used to implement automatic bulk sequential transfers into and out of the chip, and it was clear there was no sense in which data could be bulk transfered into or out of the chip.  it gets transfered one byte at a time, and the address bus has to be manually set under CPU control for every byte because after each operation which address will be next is random.  that understanding was incorrect:  the GPIF system is designed to automate the bit banging for a single I/O operation, and while it provides the machinery to allow it to run a sequence of transfers that's not the only use case.  the timing requirements for a single read or write operation mean that quite a few NOPs need to be inserted, so it didn't seem like the performance of a purely CPU based implementation was going to be a problem anyway.

I still think that's a fair assessment, but having now a fully working, reasonably performant pure CPU implementation, and having now looked more carefully at the GPIF interface documentation through the lens of experience, I can see how it would be useful and it's too bad I can't experiment with it.  the GPIF could have been used to fire off single address read/write operations in the background under hardware control while the command processor sotware decoded the next command in parallel.  command decoding is so slow that reducing the cost of the bit banging I/O cycles to nearly 0 by running them in parallel with the command processor would not be a significant change in the total speed, maybe 10% or 20% at best, but it's not nothing and if I ever switch to a binary command format the command processing could become nearly free and then speeding up the bit banging would become a bit deal.

anyway, the point here is that the wiring is all totally wrong, now, to even experiment with this because the pin assignments I chose are incompatible with the use of the GPIF subsystem.  the 8 bit data bus must be on port B for a GPIF based I/O implementation.  the !RD and !WR lines would have to be connected to two of the CTRL lines instead of GPIO lines.  the !RESET line could also be connected to a third CTRL line, there are enough of them available, but that wouldn't be necessary, and maybe better the way it is on a GPIO with a pull-down resistor.

I chose the wiring the way I did because if I wasn't using the GPIF system then all that mattered was a wiring plan that made the connections to the ALLPRO motherboard convenient.

in the future, I would say as a general rule:  if there's a data bus, at least connect those bits to port B (or B & D if it's 16 bits).  it doesn't matter if the GPIF isn't going to be used, at least by doing this that decision can be revisted later.  cutting traces and installing jumpers for two or three control lines isn't a big deal, but redoing all the bus connections to the chip is ridiculous, that's "make a new PCB" level of changing your mind.
